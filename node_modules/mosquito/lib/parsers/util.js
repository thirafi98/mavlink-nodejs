'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.couldDeclareClass = couldDeclareClass;
exports.identIsExport = identIsExport;
exports.searchDeclarations = searchDeclarations;
exports.getClassFromDeclaration = getClassFromDeclaration;
exports.getConstructorParamsFromClassDeclaration = getConstructorParamsFromClassDeclaration;
exports.paramListCantInject = paramListCantInject;
function couldDeclareClass(ident) {
	return ident === 'VariableDeclaration' || ident === 'ClassDeclaration';
}

function identIsExport(ident) {
	return ident === 'ExportNamedDeclaration' || ident === 'ExportSpecifier' || ident === 'ExportDefaultDeclaration' || ident === 'ExportAllDeclaration';
}

function* searchDeclarations(node) {
	if (couldDeclareClass(node.type)) {
		yield node;
		// $FlowFixMe Symbol.iterator in an array
	} else if (node.body && node.body[Symbol.iterator]) {
		// Only delve into iterable bodies (generally top level,
		for (const subnode of node.body) {
			yield* searchDeclarations(subnode);
		}
	}
}

function getClassFromDeclaration(node) {
	if (node.type === 'ClassDeclaration') {
		return node;
	} else if (node.type === 'VariableDeclaration') {
		return node.declarations.reduce((c, dec) => {
			if (c == null) {
				return dec.init && dec.init.type === 'ClassExpression' ? dec.init : null;
			}
			return null;
		}, null);
	}
	return null;
}

function getConstructorParamsFromClassDeclaration(node) {
	const bodyParts = node.body.body;

	const constructor = bodyParts.reduce((c, dec) => {
		if (c == null) {
			return dec.kind && dec.kind === 'constructor' ? dec : null;
		}
		return c;
	}, null);

	if (constructor == null) return null;
	const types = [];
	constructor.params.forEach(param => {
		if (param.typeAnnotation) {
			types.push(param.typeAnnotation);
		} else {
			types.push(null);
		}
	});

	return types;
}

function paramListCantInject(list) {
	return list.every(param => param == null);
}