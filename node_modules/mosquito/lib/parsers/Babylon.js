'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.BabylonParser = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _babylon = require('babylon');

var _babelGenerator = require('babel-generator');

var _babelGenerator2 = _interopRequireDefault(_babelGenerator);

var _nodeUuid = require('node-uuid');

var _nodeUuid2 = _interopRequireDefault(_nodeUuid);

var _babelCore = require('babel-core');

var _util = require('./util');

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class BabylonParser {

	constructor(str, opts = {}) {
		this.options = {};
		this.cachedTree = null;
		this.cachedBody = null;

		this.source = str;
		if (!opts.hasOwnProperty('filename')) {
			opts.filename = `${_nodeUuid2.default.v4()}.js`;
		}
		this.options = _extends({}, opts, {
			sourceType: 'module',
			plugins: ['flow', 'classProperties'].concat(opts.plugins || [])
		});
	}

	get tree() {
		if (this.cachedTree == null) {
			this.createCachedTree();
		}
		if (this.cachedTree == null) throw new Error('Parse tree was undefined after assignment');
		return this.cachedTree;
	}

	createCachedTree() {
		if (this.cachedTree != null) return;
		this.cachedBody = (0, _babylon.parse)(this.source, this.options);
		this.cachedTree = this.cachedBody.program;
	}

	getExportedClasses() {
		const declarations = [];

		this.tree.body && this.tree.body.forEach(node => {
			for (const dec of util.searchDeclarations(node)) {
				declarations.push(dec);
			}
		});

		return declarations;
	}

	transform(replacers) {
		const possibleDeclarations = this.getExportedClasses();
		const classes = possibleDeclarations.map(util.getClassFromDeclaration).filter(b => b != null);
		let copy = String(this.source);
		classes.sort((a, b) => a == null || b == null ? 0 : a.start < b.start ? 1 : -1).forEach(clazz => {
			if (clazz == null) return; // These are already filtered out, but flow wants this for piece of mind
			const params = util.getConstructorParamsFromClassDeclaration(clazz);
			if (params == null) return;
			const skip = util.paramListCantInject(params);
			if (!skip) {
				const injectables = params.map(param => param && param.typeAnnotation ? param.typeAnnotation.id.name : null);
				const name = clazz.id ? clazz.id.name : null;
				if (name == null) return; // Don't attempt to hijack anonymous classes
				let replacement = '';
				const classCode = (0, _babelGenerator2.default)(clazz).code;
				if (clazz.type === 'ClassExpression') {
					replacement = replacers.ClassExpression(classCode, injectables);
				} else if (clazz.type === 'ClassDeclaration') {
					replacement = replacers.ClassDeclaration(name, classCode, injectables);
				}
				const start = copy.substring(0, clazz.start);
				const end = copy.substring(clazz.end);

				copy = start + replacement + end;
			}
		});

		return (0, _babelCore.transform)(copy, { plugins: ['transform-flow-strip-types', 'transform-class-properties'] }).code;
	}

}
exports.BabylonParser = BabylonParser;