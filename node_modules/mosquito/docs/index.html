<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mosquito - DI Done Better</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/skeleton/2.0.4/skeleton.min.css">
	<style>
		body {
			background-color: #fffff5;
			color: #0d0d0d;
		}
		header {
			text-align: center;
		}
		header nav {
			display: flex;
		}
		header nav a {
			flex: 1;
		}
		header nav a:not(:last-child) {
			border-right: 1px grey solid;
		}
		section {
			margin: 1em;
		}
		.text-small {
			font-size: 80%;
			margin-top: -10px;
		}
	</style>
</head>
<body>
	<main class="container">
		<header>
			<h1>Mosquito</h1>
			<h2>Flowtype Based Dependency Injection</h2>
			<nav>
				<a href="#install">Getting Started</a>
				<a href="#ramble">Interlude</a>
				<a href="#usage">Usage</a>
				<a href="#api">API</a>
				<a href="https://github.com/commander-lol/mosquito">Github</a>
			</nav>
		</header>
		<section>
			<h1><a name="install"></a>Getting Started</h1>
			<p>
				Realistically, you probably just want to get this installed and to have a play around before delving too
				deep into the rest of the really interesting words in this document. Getting Mosquito set up and installed
				is incredibly simple - just make sure you've created a node project first, and that you've got a terminal
				open in the relevant directory;
			</p>

			<pre><code>npm install --save mosquito</code></pre>

			<p>
				Pretty painless, right? You can use whatever tool you prefer, whether that be <code>ied i</code> or
				<code>yarn add</code>.
			</p>
			<p>
				The next step is to require mosquito in your code - at a basic level you don't even need to hold a reference
				to the module, simply having <code>require('mosquito')</code> at the entry point to your application will
				kick off all of the black magic involved in providing injection to your classes. The important thing here is
				that any modules loaded before mosquito <em>will not have any injection provided automatically</em>. It is,
				however, possible to create a bound* version of any class at a later point in time, so there is no need to fret
				if you don't have complete control over the order modules are loaded in.
			</p>
			<p>
				Further details are provided in the <a href="#usage">usage</a> section.
			</p>
			<p class="text-small">
				*A class is considered "bound" when the container intercepts a call to the constructor in order to provide
				constructor arguments automatically (injecting dependencies)
			</p>
		</section>
		<section>
			<h1><a name="ramble"></a>Interlude</h1>
			<p>
				This section is entirely optional knowledge in terms of understanding how the library works. It is, however,
				useful if you want to know the rationale behind this library and some of the design choices.
			</p>
			<p>
				Before we get to the usage, some questions; why do you need dependency injection in Node? Surely being able to
				use <code>require</code> is more than enough? Well, yes and no. Yes, <code>require</code> is a perfectly good
				way of loading modules, the majority of which will act as dependencies in your codebase. But it's also a bad
				way of providing contextual dependencies, or providing instances of certain types without also requiring an
				amount of boilerplate at the call site. While there are ways of avoiding such things (like exporting factories
				or builder objects), the process of manually managing dependencies is another step that could introduce bugs.
			</p>
			<p>
				Would it not be better, then, to leverage existing well maintained tools to provide a more transparent DI
				experience?
			</p>
		</section>
	</main>
</body>
</html>
